/*
 * This file is autogenerated by wuschl. Don't make any changes to it,
 * as they might be overwritten.
 */
#ifndef TEST_FUZZ_ISIS_TLV_TEST_H
#define TEST_FUZZ_ISIS_TLV_TEST_H

#define _GNU_SOURCE 1

#include <dirent.h>
#include <errno.h>
#include <libgen.h>
#include <limits.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>

struct testcase {
	char *input;
	size_t input_len;
	char *output;
	size_t output_len;
	int ret;
};

static char **_testlist;
static int _testlist_len;

static int test(FILE *input, FILE *output);

static int run_testcase(const char *id, struct testcase *t, bool verbose)
{
	char *output = NULL;
	size_t output_len = 0;
	FILE *o = open_memstream(&output, &output_len);
	FILE *i = fmemopen(t->input, t->input_len, "r");

	int ret = test(i,o);

	fflush(o);
	fclose(o);

	if (output_len != t->output_len
	    || memcmp(output, t->output, output_len)) {
		printf("Test %s failed, output differs.\n", id);
		if (verbose) {
			printf("Expected output:\n%.*s", (int)t->output_len, t->output);
			printf("Received output:\n%.*s\n", (int)output_len, output);
		}
		free(output);
		return 1;
	} else if (verbose) {
		printf("Output matches.\n");
	}

	free(output);

	if (ret != t->ret) {
		printf("Test %s failed, retval differs.\n", id);
		if (verbose) {
			printf("Expected retval == %d, received retval == %d\n",
			       t->ret, ret);
		}
		return 0;
	} else if (verbose) {
		printf("Return code matches.\n");
	}

	printf("Test %s passed.\n", id);
	return 0;
}

static char *read_buf(const char *file, size_t *len)
{
	FILE *f;
	long file_size;
	char *buf;

	f = fopen(file, "r");
	if (!f)
		return NULL;

	fseek(f, 0, SEEK_END);
	file_size = ftell(f);
	fseek(f, 0, SEEK_SET);

	buf = malloc(file_size);
	fread(buf, file_size, 1, f);
	fclose(f);
	if (len)
		*len = file_size;
	return buf;
}

static void get_testlist(const char *self)
{
	char basepath[PATH_MAX];
	struct dirent **namelist;
	snprintf(basepath, sizeof(basepath), "%s_data/testcases", self);

	_testlist_len = scandir(basepath, &namelist, NULL, alphasort);
	if (_testlist_len < 0) {
		_testlist_len = 0;
		_testlist = 0;
		return;
	}
	_testlist = malloc(sizeof(*_testlist) * _testlist_len);

	int skipped = 0;
	for (int i = 0; i < _testlist_len; i++) {
		struct dirent *name = namelist[i];
		if (name->d_name[0] == '.') {
			skipped++;
			continue;
		}
		_testlist[i - skipped] = strdup(name->d_name);
		free(name);
	}
	free(namelist);
	_testlist_len -= skipped;
}

static int run_testcase_id(const char *self, char *id, bool verbose)
{
	char basepath[PATH_MAX], path[PATH_MAX];
	char *retval;
	struct testcase t = {NULL};
	int rv = 1;

	snprintf(basepath, sizeof(basepath), "%s_data/testcases/%s",self,id);

	snprintf(path, sizeof(path), "%s/input", basepath);
	t.input = read_buf(path, &t.input_len);
	snprintf(path, sizeof(path), "%s/output", basepath);
	t.output = read_buf(path, &t.output_len);
	snprintf(path, sizeof(path), "%s/retval", basepath);
	retval = read_buf(path, NULL);

	if (!t.input || !t.output || !retval) {
		fprintf(stderr, "Could not read testcase info.\n");
		goto out;
	}

	t.ret = atoi(retval);
	rv = run_testcase(id, &t, verbose);
out:
	free(t.input);
	free(t.output);
	free(retval);
	return rv;
}

static int run_all(const char *self)
{
	int failed = 0;

	get_testlist(self);

	for (int i = 0; i < _testlist_len; i++) {
		failed += run_testcase_id(self, _testlist[i], false);
		free(_testlist[i]);
	}
	free(_testlist);
	printf("%d of %d tests passed.\n", _testlist_len-failed, _testlist_len);
	printf("%d of %d tests failed.\n", failed, _testlist_len);

	return failed;
}

static const char *get_self(char *arg0)
{
	static char self[PATH_MAX];
	char buf[PATH_MAX];
	char *rv;

	const char *base = basename(arg0);
	if (strlen(base) > 3 && strncmp(base, "lt-", 3)) {
		rv = realpath(arg0, self);
		return rv;
	}

	rv = realpath(dirname(arg0), buf);
	if (!rv)
		return NULL;

	snprintf(self, sizeof(self), "%s/../%s", rv, &base[3]);
	return self;
}

int main(int argc, char **argv)
{
	if (argc == 2 && !strcmp(argv[1], "-r"))
		return test(stdin, stdout);

	const char *self = get_self(argv[0]);
	if (!self) {
		fprintf(stderr, "Could not figure out own location: %s\n",
		        strerror(errno));
		return 1;
	}

	if (argc == 2 && argv[1][0] != '-') {
		return run_testcase_id(self, argv[1], true);
	}

	if (argc == 1)
		return run_all(self);
	return 1;
}

#endif